y = supplied)
args$x = range
args$y = obj(range)
do.call(plot, args)
}
lines.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. All go into the plot.
supplied = list(...)
defaults = list(type = "l",
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(lines, args)
}
points.kdensity = function(obj, ...) {
lines.kdensity(obj, type = "p", ...)
}
print.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall:\n", deparse(attr(obj, "call")), "\n\n",
"Data:      ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth: ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:   (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:    ", attr(obj, "kernel"), "\n",
"Start:     ", attr(obj, "start"), sep = "")
}
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:      ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth: ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:   (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:    ", attr(obj, "kernel"), "\n",
"Start:     ", attr(obj, "start"),
"Range:     (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:       ", attr(obj, "has.na"),
sep = "")
}
summary(kdensity(data))
get_range = function(obj) {
support = attr(obj, "support")
minimum = attr(obj, "range")[1]
maximum = attr(obj, "range")[2]
obj_range = maximum - minimum
addition = obj_range/10
xmin = max(minimum - addition, support[1])
xmax = min(maximum + addition, support[2])
seq(xmin, xmax, length.out = 1000)
}
plot.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. They are modelled
## after the structure of the 'density' function.
supplied = list(...)
defaults = list(type = "l",
main = deparse(attr(obj, "call")),
ylab = "Density",
xlab = paste("N =", attr(obj, "n"), "  Bandwidth =", formatC(attr(obj, "bw"))),
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(plot, args)
}
lines.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. All go into the plot.
supplied = list(...)
defaults = list(type = "l",
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(lines, args)
}
points.kdensity = function(obj, ...) {
lines.kdensity(obj, type = "p", ...)
}
print.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall:\n", deparse(attr(obj, "call")), "\n\n",
"Data:      ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth: ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:   (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:    ", attr(obj, "kernel"), "\n",
"Start:     ", attr(obj, "start"), sep = "")
}
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:      ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth: ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:   (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:    ", attr(obj, "kernel"), "\n",
"Start:     ", attr(obj, "start"), "\n",
"Range:     (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:       ", attr(obj, "has.na"),
sep = "")
}
summary(kdensity(data))
str(kdensity(data))
get_range = function(obj) {
support = attr(obj, "support")
minimum = attr(obj, "range")[1]
maximum = attr(obj, "range")[2]
obj_range = maximum - minimum
addition = obj_range/10
xmin = max(minimum - addition, support[1])
xmax = min(maximum + addition, support[2])
seq(xmin, xmax, length.out = 1000)
}
plot.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. They are modelled
## after the structure of the 'density' function.
supplied = list(...)
defaults = list(type = "l",
main = deparse(attr(obj, "call")),
ylab = "Density",
xlab = paste("N =", attr(obj, "n"), "  Bandwidth =", formatC(attr(obj, "bw"))),
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(plot, args)
}
lines.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. All go into the plot.
supplied = list(...)
defaults = list(type = "l",
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(lines, args)
}
points.kdensity = function(obj, ...) {
lines.kdensity(obj, type = "p", ...)
}
print.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall:\n", deparse(attr(obj, "call")), "\n\n",
"Data:      ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth: ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:   (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:    ", attr(obj, "kernel"), "\n",
"Start:     ", attr(obj, "start"), sep = "")
}
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:       ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth:  ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:    (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:     ", attr(obj, "kernel"), "\n",
"Start:      ", attr(obj, "start"), "\n",
"Range:      (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:        ", attr(obj, "has.na"),
"Adjustment: ", attr(adjust, "adjust"),
sep = "")
}
summary(kdensity(data))
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:       ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth:  ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:    (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:     ", attr(obj, "kernel"), "\n",
"Start:      ", attr(obj, "start"), "\n",
"Range:      (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:        ", attr(obj, "has.na"),
"Adjustment: ", attr(obj, "adjust"),
sep = "")
}
summary(kdensity(data))
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:       ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth:  ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:    (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:     ", attr(obj, "kernel"), "\n",
"Start:      ", attr(obj, "start"), "\n",
"Range:      (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:        ", attr(obj, "has.na"), "\n"
"Adjustment: ", attr(obj, "adjust"),
sep = "")
}
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:       ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth:  ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:    (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:     ", attr(obj, "kernel"), "\n",
"Start:      ", attr(obj, "start"), "\n",
"Range:      (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:        ", attr(obj, "has.na"), "\n",
"Adjustment: ", attr(obj, "adjust"),
sep = "")
}
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:       ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth:  ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:    (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:     ", attr(obj, "kernel"), "\n",
"Start:      ", attr(obj, "start"), "\n",
"Range:      (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:        ", attr(obj, "has.na"), "\n"
"Adjustment: ", attr(obj, "adjust"),
sep = "")
}
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:       ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth:  ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:    (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:     ", attr(obj, "kernel"), "\n",
"Start:      ", attr(obj, "start"), "\n",
"Range:      (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:        ", attr(obj, "has.na"), "\n",
"Adjustment: ", attr(obj, "adjust"),
sep = "")
}
summary(kdensity(data))
### ===========================================================================
### GENERICS
### This package shoud support the following generics:
### -- plot, points, lines: Should work through the same interface.
### -- summary, print: Should be similar to 'density'
### ===========================================================================
### Testing of the plotting generics.
set.seed(1337)
data = rbeta(100, 2, 7)
obj = kdensity(data, start = "beta", kernel = "gauss", bw = 0.1)
plot(obj)
lines(obj, col = "red", lty = 4, lwd = 4)
points(obj, col = "blue", pch = 5, range = seq(0, 1, by = 0.1))
### Testing of printing generics.
obj
summary(obj)
get_range = function(obj) {
support = attr(obj, "support")
minimum = attr(obj, "range")[1]
maximum = attr(obj, "range")[2]
obj_range = maximum - minimum
addition = obj_range/10
xmin = max(minimum - addition, support[1])
xmax = min(maximum + addition, support[2])
seq(xmin, xmax, length.out = 1000)
}
plot.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. They are modelled
## after the structure of the 'density' function.
supplied = list(...)
defaults = list(type = "l",
main = deparse(attr(obj, "call")),
ylab = "Density",
xlab = paste("N =", attr(obj, "n"), "  Bandwidth =", formatC(attr(obj, "bw"))),
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(plot, args)
}
lines.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. All go into the plot.
supplied = list(...)
defaults = list(type = "l",
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(lines, args)
}
points.kdensity = function(obj, ...) {
lines.kdensity(obj, type = "p", ...)
}
print.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall:\n", deparse(attr(obj, "call")), "\n\n",
"Data:      ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth: ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:   (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:    ", attr(obj, "kernel"), "\n",
"Start:     ", attr(obj, "start"), "\n\n"
sep = "")
}
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:       ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth:  ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:    (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:     ", attr(obj, "kernel"), "\n",
"Start:      ", attr(obj, "start"), "\n",
"Range:      (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:        ", attr(obj, "has.na"), "\n",
"Adjustment: ", attr(obj, "adjust"), "\n\n",
sep = "")
}
get_range = function(obj) {
support = attr(obj, "support")
minimum = attr(obj, "range")[1]
maximum = attr(obj, "range")[2]
obj_range = maximum - minimum
addition = obj_range/10
xmin = max(minimum - addition, support[1])
xmax = min(maximum + addition, support[2])
seq(xmin, xmax, length.out = 1000)
}
plot.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. They are modelled
## after the structure of the 'density' function.
supplied = list(...)
defaults = list(type = "l",
main = deparse(attr(obj, "call")),
ylab = "Density",
xlab = paste("N =", attr(obj, "n"), "  Bandwidth =", formatC(attr(obj, "bw"))),
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(plot, args)
}
lines.kdensity = function(obj, range = NULL, ...) {
if(is.null(range)) range = get_range(obj)
## Potential arguments in ellipses are handled here. All go into the plot.
supplied = list(...)
defaults = list(type = "l",
lwd  = 1)
args = listmerge(x = defaults,
y = supplied)
args$x = range
args$y = obj(range)
do.call(lines, args)
}
points.kdensity = function(obj, ...) {
lines.kdensity(obj, type = "p", ...)
}
print.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall:\n", deparse(attr(obj, "call")), "\n\n",
"Data:      ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth: ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:   (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:    ", attr(obj, "kernel"), "\n",
"Start:     ", attr(obj, "start"), "\n\n",
sep = "")
}
summary.kdensity <- function(obj, digits = NULL, ...)
{
cat("\nCall: \n", deparse(attr(obj, "call")), "\n\n",
"Data:       ", attr(obj, "data.name"), " (",attr(obj, "n"), " obs.)\n",
"Bandwidth:  ", formatC(attr(obj, "bw"), digits = digits), "\n",
"Support:    (", attr(obj, "support")[1], ", ", attr(obj, "support")[2],   ")\n",
"Kernel:     ", attr(obj, "kernel"), "\n",
"Start:      ", attr(obj, "start"), "\n",
"Range:      (", attr(obj, "range")[1], ", ", attr(obj, "range")[2],   ")\n",
"NAs:        ", attr(obj, "has.na"), "\n",
"Adjustment: ", attr(obj, "adjust"), "\n\n",
sep = "")
}
### Testing of printing generics.
obj
summary(obj)
?plot
?kdensity
devtools::load_all(".")
#' Kernel density estimator with parametric start
#'
#' @export
#' @param x the supplied data.
#' @param bw a bandwidth function (NOT IMPLEMENTED) or a double
#' @param adjust an adjustment constant, so that h = adjust*bw*m, where m
#' varies acccording to the chosen kernel.
#' @param kernel the kernel function, chosen from a list of alternatives
#' @param start choice of parametric start. Can either be chosen from a vector
#' of strings, or be supplied via a list containing a \code{density} function
#' and an \code{estimator} function.
#' @param support the support of the data. Must be compatible with the supplied
#' \code{x} and the supplied \code{start} and \code{kernel}
#' @param normalized should the density be normalized?
#' @param na.rm should \code{NA} values be removed?
#' @return A function of class kdensity.
#' @details fill in
kdensity = function(x, bw = 0.1, adjust = 1, support = NULL, na.rm = TRUE, normalized = TRUE,
kernel = c("gaussian",
"epanechnikov",
"rectangular",
"triangular",
"biweight",
"cosine",
"optcosine",
"tricube",
"triweight",
"laplace"),
start =  c("uniform",
"normal",
"gamma",
"exponential",
"inverse_gaussian",
"lognormal",
"beta",
"laplace")) {
## We handle the kernel functions. This works by matching the strings and
## obtaining the kernel function from outside the 'kdensity' function itself.
kernel = match.arg(kernel)
kernel_str = kernel
kernel = get_kernel(kernel)
## Now we handle the parametric start itself. If the parametric start is a
## string, we will match the string with pre-supplied functions.
if(!is.list(start)) {
start = match.arg(start)
start_str = start
start = kdensity_start_functions(start, support)
} else {
start_str = "user supplied"
}
## The support is automatically handled if unspecified.
if(is.null(support)) {
support = get_support(start_str, kernel_str)
}
## We continue by checking if the supplied values make sense.
if(!all(x <= support[2] & x >= support[1])) {
stop("The supplied data x is not contained in the support: (",
support[1], ", ", support[2], ").")
}
if(!is.element("estimator", names(start)) | !is.element("density", names(start))) {
stop("The argument 'start' should be either 1.) a string specifying an implemented
start density or, 2.) a list containing two functions 'density' and 'estimator")
}
parameters = start$estimator(x)
parametric_start = start$density
parametric_start_vector = function(data) {
sapply(data, function(datum) {
do.call(parametric_start, as.list(c("x" = datum, parameters)))
})
}
## The parameter h is computed. The basic bandwidth is h = bw*adjust for the
## normal kernel, and is adjusted for all the other kernels so that the sd
## of the kernel equals h.
h = bw*adjust*get_kernel_sd(kernel_str)
## The denominator can be computed once and for all.
parametric_start_data = parametric_start_vector(x)
## Now we handle normalization. If the supplied start density is uniform,
## there is nothing to do. If it isn't uniform, the R-function integrate is
## used to find the normalization constant unless normalized is FALSE.
normalization = 1
if(normalized & !(start_str == "uniform" & all(support == c(-Inf, Inf)))) {
pre_function = function(y) {
if(length(y) == 1) {
mean(1/h*kernel((y-x)/h)*parametric_start_vector(y)/parametric_start_data)
} else {
sapply(y, function(y) mean(1/h*kernel((y-x)/h)*parametric_start_vector(y)/parametric_start_data))
}
}
normalization = tryCatch(integrate(pre_function, lower = support[1], upper = support[2])$value,
error = function(e) {
stop("Normalization error! The function won't integrate. Try different
support?")
})
}
## This is the main part of the returned object.
return_function = function(y) {
if(length(y) == 1) {
mean(1/h*kernel((y-x)/h)*parametric_start_vector(y)/parametric_start_data)/normalization
} else {
sapply(y, function(y) {
parametric_start_vector_y = parametric_start_vector(y)
1/h*mean(kernel((y-x)/h)*parametric_start_vector_y/parametric_start_data)/normalization
})
}
}
## Finally, we assign the return_function its class and required attributes.
class(return_function) = "kdensity"
attr(return_function, "bw")        = bw
attr(return_function, "kernel")    = kernel_str
attr(return_function, "start")     = start_str
attr(return_function, "support")   = support
attr(return_function, "adjust")    = adjust
attr(return_function, "n")         = length(x)
attr(return_function, "h")         = h
attr(return_function, "data.name") = deparse(substitute(x))
attr(return_function, "has.na")    = any(is.na(x))
attr(return_function, "call")      = match.call()
attr(return_function, "range")     = c(min(x), max(x))
return_function
}
devtools::load_all(".")
devtools::load_all(".")
library(kdensity)
devtools::load_all(".")
get_support
